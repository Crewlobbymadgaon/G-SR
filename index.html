<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>G&SR — Konkan Railway (Offline Book)</title>
  <meta name="theme-color" content="#0b63d6">
  <style>
    :root{
      --bg:#f6f9ff; --card:#fff; --kr:#0b63d6; --kr2:#0b9cff; --muted:#6b7280;
      --header-h:64px; --footer-h:60px; --desktop-break:980px; --page-gap:24px; --page-max-width:1200px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Arial;background:var(--bg);color:#071033}
    header{position:fixed;left:0;right:0;top:0;height:var(--header-h);display:flex;align-items:center;gap:12px;padding:10px 14px;background:linear-gradient(90deg,var(--kr),var(--kr2));color:#fff;z-index:1200}
    .brand{flex:1;text-align:center;font-weight:800}
    .menu-btn{width:44px;height:44px;display:grid;place-items:center;border-radius:10px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);cursor:pointer}
    .hamburger{width:22px;height:16px;position:relative}
    .hamburger span{position:absolute;left:0;right:0;height:2px;background:#fff;border-radius:2px;transition:.24s}
    .hamburger span:nth-child(1){top:0} .hamburger span:nth-child(2){top:7px} .hamburger span:nth-child(3){top:14px}

    /* small header controls */
    .hdr-controls{display:flex;gap:8px;align-items:center}
    .btn { background:rgba(255,255,255,0.12); color:#fff; border:1px solid rgba(255,255,255,0.18); padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:700; font-size:0.95rem; }
    .btn.secondary{ background:transparent; border:1px dashed rgba(255,255,255,0.14); }
    .toggle { display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:8px; background:rgba(255,255,255,0.06); }
    .spinner { width:14px; height:14px; border-radius:50%; border:2px solid rgba(255,255,255,0.25); border-top-color:#fff; animation:spin 800ms linear infinite; display:inline-block; vertical-align:middle; margin-left:6px; }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    main{padding:calc(var(--header-h) + 12px) 16px calc(var(--footer-h) + 16px);max-width:var(--page-max-width);margin:0 auto;min-height:320px}

    /* COVER */
    #cover { width:100%; border-radius:16px; overflow:hidden; height:520px; position:relative; background:#111; box-shadow:0 12px 30px rgba(0,0,0,.14); display:flex; align-items:center; justify-content:center; }
    #cover img{ max-width:100%; max-height:100%; width:auto; height:auto; object-fit:contain; object-position:center center; display:block; background:#111; }

    /* Start-button overlay */
    .cover-overlay{ position:absolute; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .cover-overlay .start { pointer-events:auto; background:rgba(255,255,255,0.92); color:#051229; padding:12px 18px; border-radius:10px; font-weight:800; cursor:pointer; box-shadow:0 8px 20px rgba(4,10,26,0.28); }
    .cover-status { position:absolute; left:12px; bottom:12px; background:rgba(255,255,255,0.85); color:#05204a; padding:6px 10px; border-radius:8px; font-weight:700; font-size:0.9rem; }

    /* reader (desktop page or mobile fallback) */
    #reader { margin-top:18px; display:none; }
    .mobile-chapter { background:var(--card); padding:18px; border-radius:14px; box-shadow:0 6px 18px rgba(0,0,0,.05); }

    /* desktop shell/page */
    @media(min-width:980px){
      #cover{ height: calc(100vh - var(--header-h) - var(--footer-h) - var(--page-gap)); border-radius:0; box-shadow:none; background:linear-gradient(180deg,#0f1724 0%, #061229 100%); }
      #cover img{ max-width: min(var(--page-max-width), 92vw); max-height: calc(100vh - var(--header-h) - var(--footer-h) - var(--page-gap)); }
      .page-shell{ display:flex; justify-content:center; align-items:center; width:100%; box-sizing:border-box; margin-top:18px; }
      .book-page{ width: min(var(--page-max-width), 92vw); height: calc(100vh - var(--header-h) - var(--footer-h) - var(--page-gap)); background:var(--card); border-radius:8px; overflow:hidden; box-shadow:0 12px 40px rgba(6,18,41,0.08); display:flex; flex-direction:column; margin:0 auto; }
      .page-frame{ padding:20px; overflow:auto; flex:1 1 auto; }
      .page-frame .chapter { padding:0; background:transparent; box-shadow:none; border-radius:0; }
    }

    /* fragments content */
    .chapter-content{ text-align:justify; text-justify:inter-word; hyphens:auto; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .chapter-content p{ margin:0 0 14px; line-height:1.6; color:#1b2b3a; font-size:16px; }
    .chapter-content .signature{ margin-top:24px; text-align:center; font-style:italic; color:#05204a; font-weight:600; }

    #tocDrawer{position:fixed;left:12px;top:84px;bottom:100px;width:340px;max-width:92vw;background:var(--card);border-radius:14px;padding:12px;box-shadow:0 18px 40px rgba(0,0,0,.12);opacity:0;pointer-events:none;transform:translateY(-10px);transition:.24s;z-index:1300}
    #tocDrawer.open{opacity:1;pointer-events:auto;transform:none}
    .toc-title{font-weight:800;margin:4px 0 12px;font-size:1.05rem;color:#05204a}
    footer{position:fixed;left:0;right:0;bottom:0;padding:12px;background:#fff;display:flex;justify-content:center;gap:12px;box-shadow:0 -6px 18px rgba(0,0,0,.05);z-index:1200}
    .nav-small button{background:#fff;border:1px solid #ccc;padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:700}

    /* small utilities */
    .hidden{display:none !important}
    .muted{color:#6b7280}
    .status-small{font-size:0.9rem;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,0.9);color:#05204a;margin-left:8px}
  </style>
</head>
<body>
  <header>
    <button id="btnMenu" class="menu-btn" aria-label="Open TOC">
      <span class="hamburger"><span></span><span></span><span></span></span>
    </button>

    <div class="brand">G&SR — Konkan Railway</div>

    <div class="hdr-controls" aria-hidden="false">
      <div id="autoUpdateWrap" class="toggle" title="Auto-update on load">
        <label style="font-weight:700;font-size:0.95rem;color:#fff;margin-right:6px">Auto-update</label>
        <input id="autoUpdate" type="checkbox" style="width:18px;height:18px;border-radius:4px"/>
      </div>
      <button id="btnUpdate" class="btn" title="Fetch latest chapters from server">Update</button>
      <button id="btnRefresh" class="btn secondary" title="Reload page (hard)">Refresh</button>
    </div>
  </header>

  <nav id="tocDrawer" aria-hidden="true" aria-label="Arrangement of Rules">
    <div class="toc-title">ARRANGEMENT OF RULES</div>
    <ul id="tocList" class="toc-list" role="list" style="list-style:none;padding:0;margin:0;max-height:60vh;overflow:auto"></ul>
  </nav>

  <main>
    <section id="cover" aria-hidden="false" role="img" aria-label="Book cover image">
      <img id="coverImg"
        srcset="assets/cover-800.webp 800w, assets/cover-1200.webp 1200w, assets/cover-1600.webp 1600w"
        sizes="(max-width:640px) 95vw, (max-width:980px) 90vw, 1200px"
        src="assets/cover-1600.webp"
        alt="G&SR Konkan Railway — Book cover"
        decoding="async"
        loading="eager" />
      <div class="cover-overlay">
        <button id="startRead" class="start">Start reading ▶</button>
      </div>
      <div id="coverStatus" class="cover-status muted">Offline</div>
    </section>

    <section id="reader" aria-live="polite" tabindex="-1" style="display:none;">
      <!-- Desktop book page -->
      <div class="page-shell" id="pageShell" style="display:none;">
        <div class="book-page" id="bookPage" role="region" aria-label="Book page">
          <div class="page-frame" id="pageFrame"><div class="chapter" id="pageChapter"><!-- injected --></div></div>
        </div>
      </div>

      <!-- Mobile reader -->
      <div id="mobileReader" style="display:none;">
        <div class="chapter mobile-chapter" id="mobileChapter"><!-- injected --></div>
      </div>
    </section>
  </main>

  <footer>
    <div class="nav-small"><button id="prevBtn" aria-label="Previous">◀</button></div>
    <div class="nav-small"><button id="nextBtn" aria-label="Next">▶</button></div>
  </footer>

<script>
/* Reader + Update logic
   - Desktop: pageFrame (#pageFrame) used for fixed-size pages.
   - Mobile: original behavior, inject to #mobileChapter and keep window scroll.
   - Update: fetches chapters/{id}.html with a cache-bypass and updates in-memory cache.
   - Auto-update: optional toggle; if enabled and navigator.onLine true, update runs on load.
*/

const DESKTOP_BREAK = 980;
const VISITED_FLAG = 'gkr_had_started_reading';
const LAST_READ_KEY = 'gkr_last_read';
const SCROLL_PREFIX = 'gkr_scroll_';
const UPDATE_TS_KEY = 'gkr_last_update_ts';
const AUTO_UPDATE_KEY = 'gkr_auto_update';

const TOC = [
  { type: 'fragment', id: 'notification', label: 'Notification' },
  { type: 'fragment', id: 'resolution', label: 'Resolution' },
  { type: 'fragment', id: 'documents_accompanying', label: 'Documents Accompanying' },

  { type: 'chapter', id: 'ch1', label: 'CHAPTER I — PRELIMINARY', children: [
      { anchor:'s101', label:'1.01 Short title and commencement' },
      { anchor:'s102', label:'1.02 Definitions' },
      { anchor:'s103', label:'1.03 Classification of Stations' }
    ]
  },

  { type:'chapter', id:'ch2', label:'Chapter 2 — Definitions & Interpretations' },
  { type:'chapter', id:'ch3', label:'Chapter 3 — Personnel & Duties' },
  { type:'chapter', id:'ch4', label:'Chapter 4 — Signalling' },
  { type:'chapter', id:'ch5', label:'Chapter 5 — Block Working' },
  { type:'chapter', id:'ch6', label:'Chapter 6 — Train Operations' },
  { type:'chapter', id:'ch7', label:'Chapter 7 — Speed Restrictions' },
  { type:'chapter', id:'ch8', label:'Chapter 8 — Signalling Failures' },
  { type:'chapter', id:'ch9', label:'Chapter 9 — Block Instruments & Communication' },
  { type:'chapter', id:'ch10', label:'Chapter 10 — Shunting & Yard Working' },
  { type:'chapter', id:'ch11', label:'Chapter 11 — Working Rules for Trains' },
  { type:'chapter', id:'ch12', label:'Chapter 12 — Safety & Emergency Procedures' },
  { type:'chapter', id:'ch13', label:'Chapter 13 — Working of Level Crossings' },
  { type:'chapter', id:'ch14', label:'Chapter 14 — Tunnels & Special Sections' },
  { type:'chapter', id:'ch15', label:'Chapter 15 — Electrical & Signalling Maintenance' },
  { type:'chapter', id:'ch16', label:'Chapter 16 — Training & Competency' },
  { type:'chapter', id:'ch17', label:'Chapter 17 — Record Keeping & Reporting' },
  { type:'chapter', id:'ch18', label:'Chapter 18 — Annexures & Forms' },
  { type:'chapter', id:'appendix', label:'Appendix — Reference Material' }
];

const FLAT = [];
TOC.forEach(item=>{
  if(item.type === 'fragment') FLAT.push({ kind:'fragment', id:item.id });
  else if(item.type === 'chapter'){
    FLAT.push({ kind:'chapter', id:item.id });
    if(item.children) item.children.forEach(sub => FLAT.push({ kind:'anchor', chapter:item.id, anchor:sub.anchor }));
  }
});

/* DOM refs */
const tocList = document.getElementById('tocList');
const btnMenu = document.getElementById('btnMenu');
const tocDrawer = document.getElementById('tocDrawer');
const cover = document.getElementById('cover');
const coverStatus = document.getElementById('coverStatus');
const startBtn = document.getElementById('startRead');
const reader = document.getElementById('reader');
const pageShell = document.getElementById('pageShell');
const pageFrame = document.getElementById('pageFrame');
const pageChapter = document.getElementById('pageChapter');
const mobileReader = document.getElementById('mobileReader');
const mobileChapter = document.getElementById('mobileChapter');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');

const btnUpdate = document.getElementById('btnUpdate');
const btnRefresh = document.getElementById('btnRefresh');
const autoUpdateCheckbox = document.getElementById('autoUpdate');

let cache = {};            // in-memory cache for chapters
let currentFlatIndex = -1; // which flat item is open
let lastHtml = null;       // last injected html

/* Build TOC UI */
function buildTOC(){
  tocList.innerHTML = '';
  TOC.forEach(item=>{
    const li = document.createElement('li');
    const btn = document.createElement('div');
    btn.className = 'toc-item';
    btn.textContent = item.label;
    btn.style.padding = '6px 8px';
    btn.style.cursor = 'pointer';
    btn.onclick = ()=> openFromTOC(item);
    li.appendChild(btn);
    tocList.appendChild(li);
    if(item.children){
      item.children.forEach(ch=>{
        const sli = document.createElement('li');
        const sbtn = document.createElement('div');
        sbtn.className = 'toc-sub';
        sbtn.textContent = ch.label;
        sbtn.style.padding = '6px 8px 6px 20px';
        sbtn.style.cursor = 'pointer';
        sbtn.onclick = ()=> openAnchor(item.id, ch.anchor);
        sli.appendChild(sbtn);
        tocList.appendChild(sli);
      });
    }
  });
}
buildTOC();

/* Menu toggle */
btnMenu.addEventListener('click', ()=>{
  const open = tocDrawer.classList.toggle('open');
  btnMenu.classList.toggle('open', open);
  btnMenu.setAttribute('aria-expanded', String(open));
  tocDrawer.setAttribute('aria-hidden', String(!open));
});
document.addEventListener('click', (e)=>{
  if(!tocDrawer.classList.contains('open')) return;
  if(e.target.closest('#tocDrawer') || e.target.closest('#btnMenu')) return;
  tocDrawer.classList.remove('open');
  btnMenu.classList.remove('open');
});

/* small helper */
function isDesktop(){ return window.innerWidth >= DESKTOP_BREAK; }

/* fetch helper with cache usage */
async function getHtml(id){
  // return in-memory cached html if present
  if(cache[id]) return cache[id];

  // if not cached, try network fetch (normal)
  try{
    const res = await fetch(`chapters/${id}.html`, { cache: 'force-cache' });
    if(res.ok){
      const t = await res.text();
      cache[id] = t;
      return t;
    }
  }catch(e){ console.warn('fetch failed for', id, e); }
  // fallback: placeholder
  return `<article class="chapter-content"><h2 style="margin-top:0">${id}</h2><p style="color:var(--muted)">Missing file: chapters/${id}.html — upload this file to show content.</p></article>`;
}

/* ---------- Open handlers ---------- */
async function openFromTOC(item){
  tocDrawer.classList.remove('open'); btnMenu.classList.remove('open');
  if(item.type === 'fragment'){ markStarted(); await openFragment(item.id); }
  else { markStarted(); await openChapter(item.id, null); }
}
async function openAnchor(chapterId, anchorId){ markStarted(); await openChapter(chapterId, anchorId); }

async function openFragment(id){
  const html = await getHtml(id);
  renderHtml(html);
  currentFlatIndex = FLAT.findIndex(f=>f.kind==='fragment' && f.id===id);
  saveLastRead({ kind:'fragment', id });
}

async function openChapter(chId, anchor=null){
  const html = await getHtml(chId);
  renderHtml(html);
  if(anchor){
    setTimeout(()=> {
      if(isDesktop()){
        const el = pageFrame.querySelector('#' + anchor);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      } else {
        const el = document.getElementById(anchor);
        if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
      }
    }, 150);
    currentFlatIndex = FLAT.findIndex(f=>f.kind==='anchor' && f.chapter===chId && f.anchor===anchor);
    saveLastRead({ kind:'chapter', id:chId, anchor });
  } else {
    currentFlatIndex = FLAT.findIndex(f=>f.kind==='chapter' && f.id===chId);
    saveLastRead({ kind:'chapter', id:chId, anchor:null });
  }
}

/* ---------- Render & show ---------- */
function renderHtml(html){
  lastHtml = html;
  cover.style.display = 'none';
  reader.style.display = 'block';

  if(isDesktop()){
    pageShell.style.display = 'flex';
    mobileReader.style.display = 'none';
    pageChapter.innerHTML = html;
    attachPageSaverIfNeeded();
    const it = (currentFlatIndex >=0 && currentFlatIndex < FLAT.length) ? FLAT[currentFlatIndex] : null;
    if(it && it.kind === 'chapter') restorePageScrollIfAny(it.id);
    pageFrame.setAttribute('tabindex','-1'); pageFrame.focus();
  } else {
    pageShell.style.display = 'none';
    mobileReader.style.display = 'block';
    mobileChapter.innerHTML = html;
    attachWindowSaverIfNeeded();
    const it = (currentFlatIndex >=0 && currentFlatIndex < FLAT.length) ? FLAT[currentFlatIndex] : null;
    if(it && it.kind === 'chapter') restoreWindowScrollIfAny(it.id);
    mobileChapter.setAttribute('tabindex','-1'); mobileChapter.focus();
  }
}

/* ---------- Show cover ---------- */
function showCover(){
  currentFlatIndex = -1;
  cover.style.display = 'flex';
  reader.style.display = 'none';
  pageShell.style.display = 'none';
  mobileReader.style.display = 'none';
  pageChapter.innerHTML = '';
  mobileChapter.innerHTML = '';
  detachPageSaver(); detachWindowSaver();
  history.replaceState({}, '', './');
}

/* ---------- Forward / Back ---------- */
nextBtn.addEventListener('click', ()=>{
  if(currentFlatIndex === -1){ if(FLAT.length > 0) openFlatItem(FLAT[0], 0); return; }
  if(currentFlatIndex < FLAT.length - 1) openFlatItem(FLAT[currentFlatIndex + 1], currentFlatIndex + 1);
});
prevBtn.addEventListener('click', ()=>{
  if(currentFlatIndex > 0) openFlatItem(FLAT[currentFlatIndex - 1], currentFlatIndex - 1);
  else showCover();
});
function openFlatItem(it, idx){ currentFlatIndex = idx; if(it.kind === 'fragment') openFragment(it.id); else if(it.kind === 'chapter') openChapter(it.id, null); else if(it.kind === 'anchor') openChapter(it.chapter, it.anchor); }

/* ---------- Save/load last-read ---------- */
function saveLastRead(obj){ try{ localStorage.setItem(LAST_READ_KEY, JSON.stringify(Object.assign({}, obj, { ts: Date.now() }))); }catch(e){} }
function loadLastRead(){ try{ const raw = localStorage.getItem(LAST_READ_KEY); return raw ? JSON.parse(raw) : null; }catch(e){ return null; } }
function markStarted(){ try{ localStorage.setItem(VISITED_FLAG, '1'); }catch(e){} }

/* ---------- Scroll savers ---------- */
/* page-frame saver (desktop) */
let pageSaver = { timer:null, lastSaved:0, id:null, handler:null };
function attachPageSaverIfNeeded(){
  detachPageSaver();
  const it = (currentFlatIndex>=0 && currentFlatIndex<FLAT.length)?FLAT[currentFlatIndex]:null;
  if(!it || it.kind!=='chapter') return;
  pageSaver.id = it.id;
  pageSaver.handler = ()=> {
    const now = Date.now();
    if(now - pageSaver.lastSaved > 800) try{ localStorage.setItem(SCROLL_PREFIX + pageSaver.id, String(Math.floor(pageFrame.scrollTop || 0))); }catch(e){}
    clearTimeout(pageSaver.timer);
    pageSaver.timer = setTimeout(()=> { try{ localStorage.setItem(SCROLL_PREFIX + pageSaver.id, String(Math.floor(pageFrame.scrollTop || 0))); }catch(e){} }, 700);
    pageSaver.lastSaved = now;
  };
  pageFrame.addEventListener('scroll', pageSaver.handler, { passive:true });
}
function detachPageSaver(){ if(pageSaver.handler) pageFrame.removeEventListener('scroll', pageSaver.handler); if(pageSaver.timer) clearTimeout(pageSaver.timer); pageSaver={ timer:null, lastSaved:0, id:null, handler:null }; }
function restorePageScrollIfAny(chId){ try{ const raw = localStorage.getItem(SCROLL_PREFIX + chId); const n = raw ? Number(raw)||0 : 0; setTimeout(()=> pageFrame.scrollTo({ top: n, behavior:'auto' }), 80); }catch(e){} }

/* window saver (mobile) */
let winSaver = { timer:null, lastSaved:0, id:null, handler:null };
function attachWindowSaverIfNeeded(){
  detachWindowSaver();
  const it = (currentFlatIndex>=0 && currentFlatIndex<FLAT.length)?FLAT[currentFlatIndex]:null;
  if(!it || it.kind!=='chapter') return;
  winSaver.id = it.id;
  winSaver.handler = ()=> {
    const now = Date.now();
    if(now - winSaver.lastSaved > 800) try{ localStorage.setItem(SCROLL_PREFIX + winSaver.id, String(Math.floor(window.scrollY || 0))); }catch(e){}
    clearTimeout(winSaver.timer);
    winSaver.timer = setTimeout(()=> { try{ localStorage.setItem(SCROLL_PREFIX + winSaver.id, String(Math.floor(window.scrollY || 0))); }catch(e){} }, 700);
    winSaver.lastSaved = now;
  };
  window.addEventListener('scroll', winSaver.handler, { passive:true });
}
function detachWindowSaver(){ if(winSaver.handler) window.removeEventListener('scroll', winSaver.handler); if(winSaver.timer) clearTimeout(winSaver.timer); winSaver={ timer:null, lastSaved:0, id:null, handler:null }; }
function restoreWindowScrollIfAny(chId){ try{ const raw = localStorage.getItem(SCROLL_PREFIX + chId); const n = raw ? Number(raw)||0 : 0; setTimeout(()=> window.scrollTo({ top: n, behavior:'auto' }), 80); }catch(e){} }

/* ---------- Update logic (fetch fresh copies from server) ---------- */
function setCoverStatus(text, busy=false){
  coverStatus.textContent = text;
  if(busy){
    if(!coverStatus.querySelector('.spinner')) {
      const s = document.createElement('span'); s.className='spinner'; s.id='covSpinner';
      coverStatus.appendChild(s);
    }
  } else {
    const s = document.getElementById('covSpinner'); if(s) s.remove();
  }
}

/* update all fragments listed in TOC (fragments + chapters) */
async function updateAllFromServer(){
  // collect unique ids that correspond to fragment/chapter files
  const ids = new Set();
  TOC.forEach(it => {
    if(it.type === 'fragment') ids.add(it.id);
    else if(it.type === 'chapter') ids.add(it.id);
  });
  const list = Array.from(ids);
  if(list.length === 0) return { ok: true, fetched: 0 };

  setCoverStatus('Updating…', true);
  btnUpdate.disabled = true;

  let fetched = 0;
  for(const id of list){
    try{
      // append timestamp to bypass caches and force reload; 'no-store' isn't accepted by fetch in some hosts, so use query
      const url = `chapters/${id}.html?_=${Date.now()}`;
      const res = await fetch(url, { cache: 'no-store' });
      if(res.ok){
        const text = await res.text();
        cache[id] = text; // update in-memory cache
        fetched++;
      } else {
        console.warn('update: failed to fetch', id, res.status);
      }
    }catch(e){
      console.warn('update catch', id, e);
    }
  }

  // bump update timestamp
  try{ localStorage.setItem(UPDATE_TS_KEY, String(Date.now())); }catch(e){}
  setCoverStatus(`Updated ${fetched}/${list.length}`, false);
  btnUpdate.disabled = false;
  // small flash
  setTimeout(()=> setCoverStatus(navigator.onLine ? 'Online' : 'Offline', false), 1500);

  // If reader is visible and a page is open, re-inject the lastHtml from cache so updated content shows
  if(reader.style.display !== 'none' && lastHtml){
    // re-render currently open item if present in cache
    if(currentFlatIndex >= 0){
      const it = FLAT[currentFlatIndex];
      if(it){
        if(it.kind === 'fragment'){
          // if updated, inject cached version
          const h = cache[it.id] || lastHtml;
          renderHtml(h);
        } else if(it.kind === 'chapter'){
          const h = cache[it.id] || lastHtml;
          renderHtml(h);
        } else if(it.kind === 'anchor'){
          // anchor belongs to chapter
          const ch = it.chapter;
          const h = cache[ch] || lastHtml;
          renderHtml(h);
          // scroll to anchor
          setTimeout(()=> {
            const el = isDesktop() ? pageFrame.querySelector('#' + it.anchor) : document.getElementById(it.anchor);
            if(el) el.scrollIntoView({behavior:'auto', block:'start'});
          }, 200);
        }
      }
    }
  }

  return { ok:true, fetched };
}

/* Auto-update checkbox */
function loadAutoUpdateSetting(){
  try{
    const v = localStorage.getItem(AUTO_UPDATE_KEY);
    autoUpdateCheckbox.checked = v === '1';
  }catch(e){
    autoUpdateCheckbox.checked = false;
  }
}
function saveAutoUpdateSetting(val){
  try{ localStorage.setItem(AUTO_UPDATE_KEY, val ? '1' : '0'); }catch(e){}
}

/* header buttons */
btnUpdate.addEventListener('click', async ()=>{
  // if offline, warn but still attempt (will likely fail)
  if(!navigator.onLine){
    if(!confirm('You appear to be offline. Update will try to fetch but may fail. Proceed?')) return;
  }
  await updateAllFromServer();
});
btnRefresh.addEventListener('click', ()=>{
  // hard refresh the app shell (not the cached content)
  location.reload(true);
});
autoUpdateCheckbox.addEventListener('change', (e)=> { saveAutoUpdateSetting(e.target.checked); });

/* ---------- Initializing + load/restore ---------- */
window.addEventListener('load', async ()=>{
  // set cover status by online state
  setCoverStatus(navigator.onLine ? 'Online' : 'Offline', false);
  loadAutoUpdateSetting();

  // register service worker if present
  try{ if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js').catch(()=>{}); } }catch(e){}

  // if auto-update enabled and online, run update
  if(autoUpdateCheckbox.checked && navigator.onLine){
    try{ await updateAllFromServer(); }catch(e){ console.warn('auto-update failed', e); }
  }

  try{
    const hadStarted = localStorage.getItem(VISITED_FLAG);
    const last = loadLastRead();
    if(!hadStarted){ showCover(); return; }
    if(last){
      if(last.kind === 'fragment'){ await openFragment(last.id); setFlatIndexFromLast(last); return; }
      if(last.kind === 'chapter'){ await openChapter(last.id, last.anchor || null); setFlatIndexFromLast(last); return; }
    }
    showCover();
  }catch(e){ console.warn(e); showCover(); }
});

/* set currentFlatIndex from last record */
function setFlatIndexFromLast(last){
  for(let i=0;i<FLAT.length;i++){
    const it = FLAT[i];
    if(last.kind === 'fragment' && it.kind === 'fragment' && it.id===last.id){ currentFlatIndex = i; return; }
    if(last.kind === 'chapter' && it.kind === 'chapter' && it.id===last.id){ currentFlatIndex = i; return; }
    if(last.kind === 'chapter' && it.kind === 'anchor' && it.chapter===last.id && it.anchor===last.anchor){ currentFlatIndex = i; return; }
  }
}

/* popstate/back handling */
window.addEventListener('popstate', (ev)=>{
  if(!ev.state){ showCover(); return; }
  const s = ev.state;
  if(s.kind === 'fragment') openFragment(s.id);
  else if(s.kind === 'chapter') openChapter(s.id, s.anchor || null);
});

/* UX helpers */
document.addEventListener('click',(e)=>{ if(!tocDrawer.classList.contains('open')) return; if(e.target.closest('#tocDrawer')||e.target.closest('#btnMenu')) return; tocDrawer.classList.remove('open'); btnMenu.classList.remove('open'); });
document.addEventListener('keydown',(e)=>{ if(e.key === 'Escape') tocDrawer.classList.remove('open'); if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='m'){ e.preventDefault(); btnMenu.click(); } });

/* expose for debugging */
window._GSR = { TOC, FLAT, openFragment, openChapter, updateAllFromServer };

/* start button on cover */
startBtn.addEventListener('click', ()=> {
  if(FLAT.length>0) openFlatItem(FLAT[0], 0);
});

/* helper to open flat item */
function openFlatItem(it, idx){ currentFlatIndex = idx; if(it.kind === 'fragment') openFragment(it.id); else if(it.kind === 'chapter') openChapter(it.id, null); else if(it.kind === 'anchor') openChapter(it.chapter, it.anchor); }

/* small helpers for update UI on online/offline toggles */
window.addEventListener('online', ()=> setCoverStatus('Online', false));
window.addEventListener('offline', ()=> setCoverStatus('Offline', false));

/* small debounce reflow on resize */
let _resize_t = null;
window.addEventListener('resize', ()=> { clearTimeout(_resize_t); _resize_t = setTimeout(()=> { if(reader.style.display !== 'none' && lastHtml) renderHtml(lastHtml); }, 160); });

/* helpers for scroll savers used elsewhere (they were implemented above as attachPageSaverIfNeeded etc) */
function attachPageSaverIfNeeded(){ attachPageSaverIfNeeded_original ? attachPageSaverIfNeeded_original() : null; }
function detachPageSaver(){ detachPageSaver_original ? detachPageSaver_original() : null; }
function attachWindowSaverIfNeeded(){ attachWindowSaverIfNeeded_original ? attachWindowSaverIfNeeded_original() : null; }
function detachWindowSaver(){ detachWindowSaver_original ? detachWindowSaver_original() : null; }

/* fallback: if original scroll saver implementations didn't exist (older file), use simplified versions */
if(typeof attachPageSaverIfNeeded_original === 'undefined'){
  // implement simple page saver here (same as earlier)
  (function(){
    // local copies
    let ps = pageSaver;
    attachPageSaverIfNeeded_original = function(){
      // re-use pageSaver defined earlier (function exists above)
      // attach only if currentFlatIndex maps to a chapter
      const it = (currentFlatIndex>=0 && currentFlatIndex<FLAT.length)?FLAT[currentFlatIndex]:null;
      if(!it || it.kind!=='chapter') return;
      detachPageSaver();
      ps.id = it.id;
      ps.handler = ()=> {
        const now = Date.now();
        if(now - ps.lastSaved > 800) try{ localStorage.setItem(SCROLL_PREFIX + ps.id, String(Math.floor(pageFrame.scrollTop || 0))); }catch(e){}
        clearTimeout(ps.timer);
        ps.timer = setTimeout(()=> { try{ localStorage.setItem(SCROLL_PREFIX + ps.id, String(Math.floor(pageFrame.scrollTop || 0))); }catch(e){} }, 700);
        ps.lastSaved = now;
      };
      pageFrame.addEventListener('scroll', ps.handler, { passive:true });
      pageSaver = ps;
    };
    detachPageSaver_original = function(){
      try{
        if(ps.handler) pageFrame.removeEventListener('scroll', ps.handler);
        if(ps.timer) clearTimeout(ps.timer);
      }catch(e){}
      ps = { timer:null, lastSaved:0, id:null, handler:null };
      pageSaver = ps;
    };
    attachWindowSaverIfNeeded_original = function(){
      let ws = winSaver;
      const it = (currentFlatIndex>=0 && currentFlatIndex<FLAT.length)?FLAT[currentFlatIndex]:null;
      if(!it || it.kind!=='chapter') return;
      detachWindowSaver_original();
      ws.id = it.id;
      ws.handler = ()=> {
        const now = Date.now();
        if(now - ws.lastSaved > 800) try{ localStorage.setItem(SCROLL_PREFIX + ws.id, String(Math.floor(window.scrollY || 0))); }catch(e){}
        clearTimeout(ws.timer);
        ws.timer = setTimeout(()=> { try{ localStorage.setItem(SCROLL_PREFIX + ws.id, String(Math.floor(window.scrollY || 0))); }catch(e){} }, 700);
        ws.lastSaved = now;
      };
      window.addEventListener('scroll', ws.handler, { passive:true });
      winSaver = ws;
    };
    detachWindowSaver_original = function(){
      try{ if(winSaver.handler) window.removeEventListener('scroll', winSaver.handler); if(winSaver.timer) clearTimeout(winSaver.timer); }catch(e){}
      winSaver = { timer:null, lastSaved:0, id:null, handler:null };
    };
  })();
}

/* restorePageScroll / restoreWindowScroll wrappers (should already exist above); if not create simple ones */
if(typeof restorePageScrollIfAny === 'undefined'){
  function restorePageScrollIfAny(chId){ try{ const raw = localStorage.getItem(SCROLL_PREFIX + chId); const n = raw ? Number(raw)||0 : 0; setTimeout(()=> pageFrame.scrollTo({ top: n, behavior:'auto' }), 80); }catch(e){} }
}
if(typeof restoreWindowScrollIfAny === 'undefined'){
  function restoreWindowScrollIfAny(chId){ try{ const raw = localStorage.getItem(SCROLL_PREFIX + chId); const n = raw ? Number(raw)||0 : 0; setTimeout(()=> window.scrollTo({ top: n, behavior:'auto' }), 80); }catch(e){} }
}

/* Ensure auto-update UI initialised */
loadAutoUpdateSetting();

/* End of script */
</script>
</body>
</html>
